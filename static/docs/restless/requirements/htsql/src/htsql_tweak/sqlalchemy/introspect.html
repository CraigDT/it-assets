<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>introspect.py</title>
  <link rel="stylesheet" href="pycco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1>introspect.py</h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-0'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-0">#</a>
        </div>
        <p>Copyright (c) 2011, Prometheus Research, LLC
See <code>LICENSE</code> for license information, <code>AUTHORS</code> for the list of authors.</p>
<h1>:mod:<code>htsql_tweak.sqlalchemy.introspect</code></h1>
<p>This module implements the introspection adapter for SQLAlchemy MetaData.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre><span class="kn">from</span> <span class="nn">htsql.introspect</span> <span class="kn">import</span> <span class="n">Introspect</span>
<span class="kn">from</span> <span class="nn">htsql.entity</span> <span class="kn">import</span> <span class="p">(</span><span class="n">CatalogEntity</span><span class="p">,</span> <span class="n">SchemaEntity</span><span class="p">,</span> <span class="n">TableEntity</span><span class="p">,</span>
                          <span class="n">ColumnEntity</span><span class="p">,</span> <span class="n">UniqueKeyEntity</span><span class="p">,</span> <span class="n">PrimaryKeyEntity</span><span class="p">,</span>
                          <span class="n">ForeignKeyEntity</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">htsql.domain</span> <span class="kn">import</span> <span class="p">(</span><span class="n">BooleanDomain</span><span class="p">,</span> <span class="n">IntegerDomain</span><span class="p">,</span> <span class="n">TimeDomain</span><span class="p">,</span>
                          <span class="n">FloatDomain</span><span class="p">,</span> <span class="n">StringDomain</span><span class="p">,</span> <span class="n">DateDomain</span><span class="p">,</span>
                          <span class="n">DateTimeDomain</span><span class="p">,</span> <span class="n">OpaqueDomain</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">htsql.connect</span> <span class="kn">import</span> <span class="n">Connect</span>
<span class="kn">from</span> <span class="nn">htsql.util</span> <span class="kn">import</span> <span class="n">Record</span>

<span class="kn">from</span> <span class="nn">htsql.context</span> <span class="kn">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">htsql.adapter</span> <span class="kn">import</span> <span class="n">weigh</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">types</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.schema</span> <span class="kn">import</span> <span class="p">(</span><span class="n">PrimaryKeyConstraint</span><span class="p">,</span> <span class="n">ForeignKeyConstraint</span><span class="p">,</span>
                               <span class="n">CheckConstraint</span><span class="p">,</span> <span class="n">UniqueConstraint</span><span class="p">)</span> </pre></div></pre></div>
      </td>
    </tr><tr id='section-1'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-1">#</a>
        </div>
        <p>override normal introspection with SQLAlchemy's MetaData</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre><span class="k">class</span> <span class="nc">SQLAlchemyIntrospect</span><span class="p">(</span><span class="n">Introspect</span><span class="p">):</span></pre></div></pre></div>
      </td>
    </tr><tr id='section-2'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-2">#</a>
        </div>
        <p>weigh(1.0)</p>
<p>def <strong>init</strong>(self):
<pre>super(SQLAlchemyIntrospect, self).<strong>init</strong>()
</pre>
def <strong>call</strong>(self):
metadata = context.app.tweak.sqlalchemy.metadata
if metadata:
<pre>return self.convert_catalog(metadata)
return super(SQLAlchemyIntrospect, self).<strong>call</strong>()
</pre>
def permit_schema(self, schema_name):
return True</p>
<p>def permit_table(self, schema_name, table_name):
return True</p>
<p>def permit_column(self, schema_name, table_name, column_name):
return True</p>
<p>def permit_columns(self, schema_name, table_name, column_names):
return all(self.permit_column(schema_name, table_name, column_name)
<pre>for column_name in column_names)
</pre>
def convert_domain(self, sqa_type):
for (test, ifso) in ((types.Boolean, BooleanDomain),
<pre>(types.Integer, IntegerDomain),
(types.DateTime, DateTimeDomain),
(types.Date, DateDomain),
(types.Time, TimeDomain)):
if isinstance(sqa_type, test):
return ifso()
if isinstance(sqa_type, types.String):
is_varying = True
if isinstance(sqa_type, (types.CHAR, types.NCHAR)):
is_varying = False
if isinstance(sqa_type, types.TEXT):
assert sqa_type.length is None
return StringDomain(sqa_type.length, is_varying)
if isinstance(sqa_type, types.Float):
return FloatDomain(sqa_type.precision)
if isinstance(sqa_type, types.Numeric):
return DecimalDomain(sqa_type.precision, sqa_type.scale)
return OpaqueDomain()
</pre>
def convert_columns(self, schema, table):
columns = []
for column in table.columns:
if not self.permit_column(schema, table.name, column.name) and 
not column.primary_key:
continue
domain = self.convert_domain(column.type)
has_default = column.server_default is not None
columns.append(ColumnEntity(schema, table.name,
<pre>column.name, domain,
column.nullable, has_default))
return columns
</pre>
def convert_unique_keys(self, schema, table):
unique_keys = []
for cons in table.constraints:
if isinstance(cons, PrimaryKeyConstraint):
column_names = []
for column in cons.columns:
column_names.append(column.name)
unique_keys.append(PrimaryKeyEntity(schema, table.name,
<pre>column_names))
continue
if isinstance(cons, UniqueConstraint):
column_names = []
for column in cons.columns:
column_names.append(column.name)
if not self.permit_columns(schema, table.name, column_names):
continue
unique_keys.append(UniqueKeyEntity(schema, table.name,
column_names))
continue
return unique_keys
</pre>
def convert_foreign_keys(self, schema, table):
foreign_keys = []
for cons in table.constraints:
if not isinstance(cons, ForeignKeyConstraint):
continue
source_names = []
for column in cons.columns:
if type(column) == str:
source_names.append(column)
else:
source_names.append(column.name)
target_columns = [e.column for e in cons.elements]
target_table = target_columns[0].table
target_schema = target_table.schema or '_'
target_names = [column.name for column in target_columns]
if not self.permit_schema(target_schema):
continue
if not self.permit_table(target_schema, target_table.name):
continue
if not self.permit_columns(schema, table.name, source_names):
continue
if not self.permit_columns(target_schema, target_table.name,
target_names):
continue
foreign_key = ForeignKeyEntity(schema, table.name, source_names,
target_schema, target_table.name, target_names)
foreign_keys.append(foreign_key)
return foreign_keys</p>
<p>def convert_tables(self, metadata):
tables = []
for table in metadata.sorted_tables:
schema_name = table.schema or '_'
if not self.permit_schema(schema_name):
continue
if not self.permit_table(schema_name, table.name):
continue
columns = self.convert_columns(schema_name, table)
unique_keys = self.convert_unique_keys(schema_name, table)
foreign_keys = self.convert_foreign_keys(schema_name, table)
table = TableEntity(schema_name, table.name, columns,
unique_keys, foreign_keys)
tables.append(table)
return tables</p>
<p>def convert_catalog(self, metadata):
buckets = {}
tables = self.convert_tables(metadata)
for table in tables:
bucket = buckets.setdefault(table.schema_name, [])
bucket.append(table)
schemas = []
for (schema_name, tables) in buckets.items():
schemas.append(SchemaEntity(schema_name, tables))
return CatalogEntity(schemas)</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre></pre></div></pre></div>
      </td>
    </tr>
  </table>
</div>
</body>
