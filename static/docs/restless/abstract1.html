<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>abstract1.py</title>
  <link rel="stylesheet" href="pycco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1>abstract1.py</h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-0'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-0">#</a>
        </div>
        
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Models and Forms and main classes to inherit::</span>

<span class="sd">    Copyright (C) 2011 Department of Environment &amp; Conservation           </span>

<span class="sd">    Authors:</span>
<span class="sd">     * Adon Metcalfe</span>
<span class="sd">                                                                            </span>
<span class="sd">    This program is free software: you can redistribute it and/or modify    </span>
<span class="sd">    it under the terms of the GNU Affero General Public License as          </span>
<span class="sd">    published by the Free Software Foundation, either version 3 of the      </span>
<span class="sd">    License, or (at your option) any later version.                         </span>
<span class="sd">                                                                            </span>
<span class="sd">    This program is distributed in the hope that it will be useful,         </span>
<span class="sd">    but WITHOUT ANY WARRANTY; without even the implied warranty of          </span>
<span class="sd">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           </span>
<span class="sd">    GNU Affero General Public License for more details.                     </span>
<span class="sd">                                                                            </span>
<span class="sd">    You should have received a copy of the GNU Affero General Public License</span>
<span class="sd">    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span></pre></div></pre></div>
      </td>
    </tr><tr id='section-1'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-1">#</a>
        </div>
        <p>Standard model imports</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">IntegrityError</span>
<span class="kn">from</span> <span class="nn">uni_form.helpers</span> <span class="kn">import</span> <span class="n">FormHelper</span><span class="p">,</span> <span class="n">Button</span>
<span class="kn">from</span> <span class="nn">django.contrib.auth.models</span> <span class="kn">import</span> <span class="n">User</span>
<span class="kn">from</span> <span class="nn">django</span> <span class="kn">import</span> <span class="n">forms</span>
<span class="kn">from</span> <span class="nn">django.utils.safestring</span> <span class="kn">import</span> <span class="n">mark_safe</span></pre></div></pre></div>
      </td>
    </tr><tr id='section-2'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-2">#</a>
        </div>
        <p>GIS model imports</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.contrib.gis</span> <span class="kn">import</span> <span class="n">admin</span>
<span class="kn">from</span> <span class="nn">django.contrib.gis.db</span> <span class="kn">import</span> <span class="n">models</span></pre></div></pre></div>
      </td>
    </tr><tr id='section-3'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-3">#</a>
        </div>
        <p>Standard libraries</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">django.template.loader</span> <span class="kn">import</span> <span class="n">render_to_string</span>
<span class="kn">from</span> <span class="nn">string</span> <span class="kn">import</span> <span class="n">Template</span>

<span class="kn">from</span> <span class="nn">django.utils</span> <span class="kn">import</span> <span class="n">simplejson</span> <span class="k">as</span> <span class="n">json</span>
<span class="kn">from</span> <span class="nn">django.conf</span> <span class="kn">import</span> <span class="n">settings</span>

<span class="kn">from</span> <span class="nn">restless.fields</span> <span class="kn">import</span> <span class="n">UTCCreatedField</span><span class="p">,</span> <span class="n">UTCLastModifiedField</span><span class="p">,</span> <span class="n">JSONField</span><span class="p">,</span> <span class="n">JSONEncoder</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span></pre></div></pre></div>
      </td>
    </tr><tr id='section-4'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-4">#</a>
        </div>
        <p>Errors</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre></pre></div></pre></div>
      </td>
    </tr><tr id='section-5'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-5">#</a>
        </div>
        <p>Base class for exceptions in this module.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre><span class="k">class</span> <span class="nc">Error</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span></pre></div></pre></div>
      </td>
    </tr><tr id='section-6'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-6">#</a>
        </div>
        <p>pass</p>
<p>class AuditError(Error):
Exception raised for errors in Audit</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre>    <span class="n">Attributes</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">--</span> <span class="n">explanation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">error</span></pre></div></pre></div>
      </td>
    </tr><tr id='section-7'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-7">#</a>
        </div>
        <p>def <strong>init</strong>(self, value):
<pre>self.value = value
def <strong>str</strong>(self):
return repr(self.value)
</pre>
class AuditCollision(AuditError):
pass</p>
<p>class SelectAutoComplete(forms.Select):
'''
Needs jquery UI, jLinq
'''
def render(self, name, value, attrs=None, choices=(), label = None):
if hasattr(self, "initial"):
<pre>value = self.initial
if value is None: value = ''
final_attrs = self.build_attrs(attrs, name=name)
final_attrs["size"] = 4
output = [u'<input%s />' % forms.util.flatatt(final_attrs)]
choiceArray = []
for val, lbl in self.choices:
choiceArray.append({"label":lbl, "value":val})
if val == value:
label = lbl
if len(choiceArray) &gt; 200:
delay, minLength = 500, 4
else:
delay, minLength = 100, 1
output.append(u'''
<label for="{1[id]}-lbl">{5}</label>
<script type="text/javascript">
$("input#{1[id]}").autocomplete({{
source: {0},
delay: {3},
select: function(event, ui) {{
$("label[for={1[id]}-lbl]").text(ui.item.label)
}},
minLength: {4}
}}).val({2})
</script>
'''.format(json.dumps(choiceArray).replace("&amp;", "&amp;"), final_attrs, value, delay, minLength, label))
return mark_safe(u'n'.join(output))
</pre>
class AuditManager(models.GeoManager):
'''
For versioning (in Audit) and naturalkey functions
must override natural key funcs with appropriate
unique constraints
'''
def get_by_natural_key(self, effective_to):
return self.get(effective_to = effective_to)</p>
<p>def natural_key_set(self, effective_to):
return self.filter()</p>
<p>def current(self):
return self.filter(effective_to = None)</p>
<p>class Audit(models.Model):
'''
Contains the effective_from, effective_to,
visible_from and visible_to fields.
Used by other tables to enable historical data entry.
Contains the date_created and date_modified fields.
Used by other tables to Display datetime information.
Uses lots of natural keys, requires:
natural_key()
<em>default_manager.get_by_natural_key()
_default_manager.natural_key_set()
'''
created_by = models.ForeignKey(
User, default=1,
related_name='%(app_label)s</em>%(class)s_created',
db_index=True)
date_created = UTCCreatedField(db_index=True)
modified_by = models.ForeignKey(
User, default=1,
related_name='%(app_label)s_%(class)s_modified',
db_index=True)
date_modified = UTCLastModifiedField(db_index=True)
effective_from = models.DateTimeField(db_index=True)
effective_to = models.DateTimeField(db_index=True, null=True, blank=True)</p>
<p>@transaction.commit_manually
def fix_versions(self):
nkey = self.natural_key()
versions = self._default_manager.natural_key_set(<em>nkey)
resetnone = False
if len(versions.filter(effective_to = None)) &gt; 1:
print("multiple active records, trying to adjust effective_to's")
resetnone = True
if len(versions.filter(effective_from = self.effective_from)) &gt; 1:
print([v.pk for v in versions])
for version in versions:
if version.effective_to != None and version.effective_from &gt; version.effective_to:
print(version.effective_to - version.effective_from)
version.effective_to = version.effective_from
version.save()
transaction.commit()
if resetnone and version.effective_to == None:
fixed = False
hop = 1
while not fixed:
try:
version.effective_to = version.get_version(version.effective_from, "next")
version.save()
fixed = True
except:
transaction.rollback()
try:
<pre>version.effective_from += timedelta(seconds=hop)
version.effective_to = version.get_version(version.effective_from, "next")
version.save()
fixed = True
except Exception, e:
transaction.rollback()
hop += 1
print(<code>e</code>, hop)
transaction.commit()
print('.', end="")
</pre>
def get_version(self, fromdate = None, todate = None):
'''
gets latest version of itself (single object)
specials = ["all", "oldest", "newest")
if fromdate passed gets version valid for that date (single object)
if todate passed, gets queryset of version valid between fromdate and todate
'''
nkey = self.natural_key()
versions = self._default_manager.natural_key_set(</em>nkey)
if fromdate == "all":
return versions
if fromdate == "oldest":
return versions.order_by("effective_from")[0]
if fromdate == "newest":
return versions.latest("effective_from")
if isinstance(fromdate, datetime):
if todate == "next":
return versions.filter(effective_from<strong>gt = fromdate).order_by("effective_from")[0]
if isinstance(todate, datetime):
history = versions.filter(effective_from</strong>lte = fromdate, effective_to<strong>gt = todate)
latest = versions.filter(effective_from</strong>lte = fromdate, effective_to = None)
return history | latest
latest = versions.latest("effective_from")
if latest.effective_from &lt; fromdate and latest.effective_to is None:
return latest
else:
return versions.get(effective_from<strong>lte = fromdate, effective_to</strong>gt = fromdate)
if fromdate is None and todate is None:
try:
return versions.get(effective_to = None)
except:
if versions.filter(effective_to = None):
raise AuditError(
"oh no multiple active versions detectedn"
"please run object.fix_versions()n"
"{0}".format(nkey)
)
else:
raise
raise AuditError("bad input, args: " + unicode(fromdate) + ', ' + unicode(todate))</p>
<p>def compare(self, other):
'''
Compares self to another object using fields minus the audit fields
'''
same = True
ignorefields = ['effective_from', 'effective_to',
'created_by', 'modified_by', 'date_modified',
'date_created', 'id']
for field in self.<strong>class</strong>._meta.fields:
if field.name not in ignorefields:
other_value = getattr(other, field.name)
try:
self_value = getattr(self, field.name)
except field.rel.to.DoesNotExist: # catches one2one relationships that don't exist yet
test = True
else:
if isinstance(other_value, dict): # if its a json field handle specially
jf = JSONField()
test = (other_value == jf.to_python(jf.from_python(self_value)))
else:
test = (self_value == other_value)
if not test:
same = False
break
return same</p>
<p>def insert_version_after(self, previous, user):
'''
inserts a record after the given record
using user to set modified on previous
'''
self.effective_to = None
if not isinstance(previous.effective_to, datetime):
pass
elif previous.effective_to &lt; self.effective_from:
if self.natural_key() == previous.natural_key():
raise AuditError("duplicate natural key: ".format(self.natural_key()))
self.clear_cache()
self.save()
return
else:
try:</p>
<h1>if theres another record, use its effective from</h1>
<p>next = self.get_version(self.effective_from, "next")
if next != previous:
self.effective_to = next.effective_from
except IndexError: pass</p>
<h1>adjust previous effective_to</h1>
<p>previous.end_version(self.effective_from, user)
if self.natural_key() == previous.natural_key():
raise AuditError("duplicate natural key: {0}".format(self.natural_key()))
self.clear_cache()
self.save()
return</p>
<p>@transaction.commit_on_success
def save_version(self, user = None, effective_to = None, validate = True):
'''
If effective from is none, makes new instance
or ends and adds an updated instance
Otherwise inserts record into the timestream
at point defined by effective_from</p>
<blockquote>
<blockquote>
<blockquote>
<p>item = Association()
item.save()
'''</p>
</blockquote>
</blockquote>
</blockquote>
<h1>invalidate id</h1>
<p>self.id = None
self.effective_to = effective_to
if user:
self.created_by = user
self.modified_by = user</p>
<p>now = self.effective_from or datetime.utcnow()</p>
<h1>if effective_to, skip checks and just insert record</h1>
<h1>used for bulk loading records quickly</h1>
<h1>won't catch duplicate data but constraints</h1>
<h1>will catch identical records</h1>
<p>if self.effective_to and self.effective_from:
self.clear_cache()
self.save()
return</p>
<h1>insert between or create record if effective_from</h1>
<p>if self.effective_from:
try:</p>
<h1>retrieve version to insert after</h1>
<p>previous = self.get_version(self.effective_from)
except self.DoesNotExist:
previous = False</p>
<h1>inserting first record</h1>
<p>try:
self.effective_to = self.get_version(self.effective_from, "next").effective_from
except IndexError: pass
else:
if validate:
if self.compare(previous):
self = previous
raise AuditCollision(unicode(previous) + ", " + unicode(self))
self.insert_version_after(previous, user)
return</p>
<h1>try to get active record(s)</h1>
<p>try:
active = self.get_version()
except self.DoesNotExist:
active = False</p>
<p>if active and self.effective_to is None:
if self.compare(active):
raise AuditCollision(unicode(active) + ", " + unicode(self))
active.end_version(now, user)
if self.natural_key() == active.natural_key():
raise AuditError("duplicate natural key: {0}".format(self.natural_key()))</p>
<h1>add fields for new record</h1>
<p>self.effective_from = self.effective_from or now
self.clear_cache()
try:
self.save()
except IntegrityError, e:
raise AuditCollision(unicode(e))
return</p>
<p>@transaction.commit_on_success
def end_version(self, effective_to = None, user = None):
effective_to = effective_to or datetime.utcnow()
self.effective_to = effective_to
if user:
self.modified_by = user
self.clear_cache()
try:
self.save()
except IntegrityError, e:
raise AuditCollision(unicode(e))
return</p>
<p>def tags_str(self):
'''
uses django-tagging
'''</p>
<h1>need to hide hidden tags</h1>
<p>return "".join("{0.name}, ".format(t) for t in self.tags)</p>
<p>@transaction.commit_on_success
def replace_tags(self, tags, user = None):
'''
tags can be space or comma separated
checks tags are different
ends current object
creates new version
assigns tags from tags string
'''
same_tags = True
for tag in tags.split(","):
tag = tag.strip()
if tag and not self.tags.filter(name=tag.strip()):
same_tags = False
if same_tags:
raise AuditCollision("same tags for {0}: {1}".format(self.pk, self.tags_str()))
self.end_version(user = user)
self.effective_from = None
self.save_version(user = user)
self.tags = tags
return</p>
<p>def append_tags(self, tags, user = None):
'''
tags must be comma separated
extends existing objects tags with tags string
calls replace_tags to create new version
'''
tags = self.tags_str() + tags
self.replace_tags(tags, user = user)</p>
<p>def natural_key_str(self):
return json.dumps(self.natural_key(), cls=JSONEncoder)</p>
<p>def as_dict(self):
return self.natural_key_str()</p>
<p>def sha1(self):
'''
unique hash for a version set of audit object
'''
return hashlib.sha1(json.dumps(self.natural_key()[1:], cls=JSONEncoder)).hexdigest()</p>
<p>def clear_cache(self):
cache.set(self.sha1(), None, 0)</p>
<p>def <strong>unicode</strong>(self):
return unicode(self.pk) + ":" + self.natural_key_str()</p>
<p>class Meta:
abstract = True</p>
<p>class LookupManager(AuditManager):
'''
For saveversion, getby (in Audit) and naturalkey functions
'''
def get_by_natural_key(self, effective_to, name):
return self.get(effective_to = effective_to, name = name)</p>
<p>def natural_key_set(self, effective_to, name):
return self.filter(name = name)</p>
<p>class Lookup(Audit):
name = models.CharField(max_length = 200, null=True, blank=True)
description = models.CharField(max_length = 200)</p>
<p>sort_field = 'description'
headers = ['Name', 'Description', 'Effective From']
objects = LookupManager()</p>
<p>def as_td(self):
template = Template('''
<td><a href="$id/">$name</a></td>
<td>$description</td>
<td>$effective_from</td>
''')
dict = self.<strong>dict</strong>
dict['effective_from'] = self.effective_from.strftime("%d-%b-%Y")
result = template.substitute(dict)
return result</p>
<p>def natural_key(self):
return [self.effective_to, self.name]</p>
<p>def <strong>unicode</strong>(self):
return u"%s" % (self.description)</p>
<p>class Meta:
abstract = True
unique_together = (("effective_from", "name"),
("effective_to", "name"))</p>
<p>class BaseForm(forms.ModelForm):
'''
Base form/modelform that can be used to make forms.
Inherits from Audit model by default, excludes
audit fields (so is a blank form). Javascripty</p>
<p>Usage::</p>
<p>class Form(BaseForm):
class Meta(BaseForm.Meta):
model = MyModel</p>
<p>class Form(BaseForm):
pass
'''
helper = FormHelper()</p>
<h1>add in a submit and reset button</h1>
<p>submit = Button('Save','Save your changes')
helper.add_input(submit)
reset = Button('Cancel','Discard your changes')
helper.add_input(reset)</p>
<p>def update(self):
self.helper.form_id = self.<strong>class</strong>.<strong>name</strong>
self.helper.form_class = self.Meta.model._meta.app_label</p>
<p>def as_html(self):
return render_to_string('form.html', { 'form': self })</p>
<p>def as_taconite(self, selector):
return render_to_string('taconite_form.html', { 'jqueryselector': selector, 'form': self })</p>
<p>class Meta:
model = Audit
exclude = ['effective_from','effective_to','created_by','modified_by']</p>
<h1>Messaging models.</h1>
<p>def dict_fallback(self):
return self.<strong>dict</strong></p>
<p>User.as_dict = dict_fallback</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><div class="highlight"><pre></pre></div></pre></div>
      </td>
    </tr>
  </table>
</div>
</body>
